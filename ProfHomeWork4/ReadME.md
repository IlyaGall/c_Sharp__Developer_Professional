- Есть базовый класс модель машины ```(ModelCar)```
- от него наследуются 2 класса ``(Truck)`` и ``(Jeep)``
- от ```(Truck)``` наследуются ```(Kamaz)```,  а от ``(Jeep)`` наследуются ``(UAZ)``

 Model Car каждая машина имеет:
* Название машины
* Цена машины
* Цвет машины
* abstract ModelCar Clone для клонирования

 Truck:ModelCar
* Объём кузова

 Jeep:ModelCar
* Понижающая передача
* Межосевая блокировка

 Kamaz:Truck
* Название модели камаза (карьерный, билаз и т.п)
* грузоподъемность грузовика (сколько можно увезти)

 UAZ:Jeep
*  наличия шноркеля (захват вохдух через специальное устройства)

 ### Вывод: Преимущества и недостатки интерфейсов
 ICloneable:
  * Преимущества:
      - Стандартный интерфейс, поддерживаемый .NET.
      - Легко интегрируется в существующие коллекции и системы.
  * Недостатки:
      - Метод `Clone` возвращает `object`, что требует приведения типа.
      - Нет условий на тип клонируемого объекта.

 IMyCloneable:
  * Преимущества:
      - Удобный параметризированный метод клонирования, что позволяет избегать ненужного приведения типа.
      - Более специфичен, даёт разработчику больше контроля.
  * Недостатки:
      - Не является стандартом, требуется собственная реализация.
      - Труднее использовать с коллекциями, ожидающими `ICloneable`.

 Таким образом, в зависимости от контекста и требований проекта, выбор интерфейса для клонирования объектов можно 
 осуществить с учётом вышеизложенных преимуществ и недостатков.